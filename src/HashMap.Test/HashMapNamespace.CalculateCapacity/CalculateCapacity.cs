// ********RoostGPT********
/*
Test generated by RoostGPT for test roostAI-csharp-sample using AI Type Azure Open AI and AI Model roost-gpt4-32k

ROOST_METHOD_HASH=CalculateCapacity_45e099104e
ROOST_METHOD_SIG_HASH=CalculateCapacity_bb934c0f00

   ########## Test-Scenarios ##########  

Scenario 1: Valid input with positive init capacity and load factor below 1

  Details:
    TestName: TestCalculateCapacityForValidInput
    Description: This test is meant to check if the method CalculateCapacity calculates the right capacity and limit capacity given valid init capacity and load factor.

  Execution:
    Arrange: Set the values for the init capacity to a positive number like 100, and the load factor to a number below 1, like 0.75.
    Act: Invoke the CalculateCapacity method with the set parameters.
    Assert: Check if the calculated capacity and limit capacity are accurate.

  Validation:
    The assertion should verify that the calculated capacity and limit capacity are as expected. It tests the method's ability to calculate the size of the hash map accurately given valid input.

Scenario 2: Zero init capacity

  Details:
    TestName: TestCalculateCapacityWithZeroInitCapacity
    Description: This test checks if the CalculateCapacity method can handle a scenario where the init capacity is set to zero.

  Execution:
    Arrange: Set the values for the init capacity to 0, and load factor to a number below 1, for example, 0.75.
    Act: Invoke the CalculateCapacity method with these parameters.
    Assert: Check if the calculated capacity and limit capacity are accurate.

  Validation:
    The assertion is verifying that the method can handle an edge case where the initial capacity is zero. The expected result would include a calculated capacity that is adjusted to avoid a division by zero error or similar problems.

Scenario 3: Negative init capacity

  Details:
    TestName: TestCalculateCapacityWithNegativeInitCapacity
    Description: This test checks if the CalculateCapacity method can handle a scenario with a negative init capacity.

  Execution:
    Arrange: Set the values for the init capacity to a negative number, for instance, -100, and the load factor to a number below 1, such as 0.75.
    Act: Invoke the CalculateCapacity method with these parameters.
    Assert: Check if the method responds appropriately to the invalid input.

  Validation:
    The assertion is verifying that the method can handle an edge scenario where the initial capacity is a negative number. The expected behaviour should be a way to handle the error properly, whether it's by throwing an exception or returning a specific value.

Scenario 4: Load factor greater than 1

  Details:
    TestName: TestCalculateCapacityWithHigherLoadFactor
    Description: This test is meant to check if the CalculateCapacity method can handle a scenario where the load factor is greater than 1.

  Execution:
    Arrange: Set the values for the init capacity to a positive number, such as 100, and the load factor to a value greater than 1, like 1.5.
    Act: Invoke the CalculateCapacity method with these parameters.
    Assert: Check how the method handles an improper load factor.

  Validation:
    This assertion aims to verify that the method can correctly handle a situation where the load factor given is greater than 1. It is expected to handle such instances correctly, either by throwing an exception or by adjusting the load factor to a valid value.
*/

// ********RoostGPT********
using NUnit.Framework;
using System;

namespace HashMapNamespace.Test
{
    public class CalculateCapacityTest
    {
        [Test]
        public void TestCalculateCapacityForValidInput()
        {
            // Arrange
            int initCapacity = 100;
            float loadFactor = 0.75f;

            // Act
            int limitCapacity;
            int result = HashHelpers.CalculateCapacity(initCapacity, loadFactor, out limitCapacity);

            // Assert
            Assert.AreEqual(initCapacity / loadFactor, result);
            Assert.AreEqual(initCapacity, limitCapacity);
        }

        [Test]
        public void TestCalculateCapacityWithZeroInitCapacity()
        {
            // Arrange
            int initCapacity = 0;
            float loadFactor = 0.75f;

            // Act
            int limitCapacity;
            int result = HashHelpers.CalculateCapacity(initCapacity, loadFactor, out limitCapacity);

            // Assert
            Assert.AreEqual(0, result);
            Assert.AreEqual(0, limitCapacity);
        }

        [Test]
        public void TestCalculateCapacityWithNegativeInitCapacity()
        {
            // Arrange
            int initCapacity = -100;
            float loadFactor = 0.75f;

            // Act
            var ex = Assert.Throws<ArgumentOutOfRangeException>(() => HashHelpers.CalculateCapacity(initCapacity, loadFactor, out var limitCapacity));

            // Assert
            Assert.That(ex.ParamName, Is.EqualTo("initCapacity"));
        }

        [Test]
        public void TestCalculateCapacityWithHigherLoadFactor()
        {
            // Arrange
            int initCapacity = 100;
            float loadFactor = 1.5f;

            // Act
            int limitCapacity;
            int result = HashHelpers.CalculateCapacity(initCapacity, loadFactor, out limitCapacity);

            // Assert
            Assert.AreEqual(initCapacity / loadFactor, result);
            Assert.AreEqual(initCapacity, limitCapacity);
        }
    }
}
