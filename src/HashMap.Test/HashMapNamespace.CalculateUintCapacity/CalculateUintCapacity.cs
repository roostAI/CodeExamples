// ********RoostGPT********
/*
Test generated by RoostGPT for test roostAI-csharp-sample using AI Type Azure Open AI and AI Model roost-gpt4-32k

ROOST_METHOD_HASH=CalculateUintCapacity_4f267d7b8a
ROOST_METHOD_SIG_HASH=CalculateUintCapacity_3048a15576

   ########## Test-Scenarios ##########  

Scenario 1: Test with a lower initialCapacity input

Details:
    TestName: TestCalculateUintCapacity_LowerInitCapacity
    Description: This test will check if the CalculateUintCapacity method can adequately calculate the required capacity when given a relatively low initial capacity value.

Execution:
    Arrange: Prepare mock data for a low initial capacity value.
    Act: Invoke CalculateUintCapacity method using the mocked initial capacity value with an appropriate mock load factor.
    Assert: Verify the calculated capacity and limit capacity against the expected values.

Validation:
    The assertion verifies that the calculated capacity and limit capacity correctly reflect the provided input parameters. This test is important to confirm that the method functions correctly when provided lower initial capacity values.

Scenario 2: Test with a higher initialCapacity input

Details:
    TestName: TestCalculateUintCapacity_HigherInitCapacity
    Description: This test will check if the CalculateUintCapacity method can adequately calculate the required capacity when given a relatively high initial capacity value.

Execution:
    Arrange: Prepare mock data for a high initial capacity value.
    Act: Invoke CalculateUintCapacity method using the mockedinitial  capacity value with an appropriate mock load factor.
    Assert: Verify the calculated capacity and limit capacity against the expected values.

Validation:
    The assertion verifies that the calculated capacity and limit capacity correspondence to the provided input parameters. This test is important to confirm that the method functions correctly when provided higher initial capacity values.

Scenario 3: Test with zero initialCapacity input

Details:
    TestName: TestCalculateUintCapacity_ZeroInitCapacity
    Description: This test will check the functionality of the CalculateUintCapacity method when the initial capacity value is zero.

Execution:
    Arrange: Prepare mock data for a zero initial capacity value.
    Act: Invoke CalculateUintCapacity method using the mocked initial capacity value with an appropriate mock load factor.
    Assert: Verify the calculated capacity and limit capacity against the expected values.

Validation:
    The assertion verifies that the calculated capacity is one and limit capacity correctly calculates with provided load factor and initial capacity value. This test is important to confirm that the method handles zero initial capacity properly.

Scenario 4: Test with negative loadFactor input

Details:
    TestName: TestCalculateUintCapacity_NegativeLoadFactor
    Description: This test will check the functionality of the CalculateUintCapacity method when the loadFactor value is negative.

Execution:
    Arrange: Prepare mock data for a valid initial capacity value but assign a negative value for loadFactor.
    Act: Invoke CalculateUintCapacity method using the mocked initial capacity value and negative loadFactor.
    Assert: Expect an ArgumentException or similar exception to be thrown as the negative loadFactor is not valid.

Validation:
    The assertion checks that the method gracefully handles invalid data inputs, specifically, a negative loadFactor by throwing an exception. This is important for validating application robustness against faulty data inputs.
*/

// ********RoostGPT********
using NUnit.Framework;
using System;

namespace HashMapNamespace.Test
{
    [TestFixture]
    public class CalculateUintCapacityTests
    {
        private HashMap target;

        [SetUp]
        public void SetUp()
        {
            target = new HashMap();
        }

        [Test]
        public void TestCalculateUintCapacity_LowerInitCapacity()
        {
            // Arrange
            uint initCapacity = 2;
            float loadFactor = 0.75f;
            uint expectedCapacity = 3;

            // Act
            uint actualCapacity = target.CalculateUintCapacity(initCapacity, loadFactor);

            // Assert
            Assert.AreEqual(expectedCapacity, actualCapacity);
        }

        [Test]
        public void TestCalculateUintCapacity_HigherInitCapacity()
        {
            // Arrange
            uint initCapacity = 200;
            float loadFactor = 0.75f;
            uint expectedCapacity = 267;

            // Act
            uint actualCapacity = target.CalculateUintCapacity(initCapacity, loadFactor);

            // Assert
            Assert.AreEqual(expectedCapacity, actualCapacity);
        }

        [Test]
        public void TestCalculateUintCapacity_ZeroInitCapacity()
        {
            // Arrange
            uint initCapacity = 0;
            float loadFactor = 0.75f;

            // Act
            uint actualCapacity = target.CalculateUintCapacity(initCapacity, loadFactor);

            // Assert
            Assert.AreEqual(0, actualCapacity);
        }

        [Test]
        public void TestCalculateUintCapacity_NegativeLoadFactor()
        {
            // Arrange
            uint initCapacity = 100;
            float loadFactor = -0.75f;

            // Act & Assert
            Assert.Throws<ArgumentOutOfRangeException>(() => target.CalculateUintCapacity(initCapacity, loadFactor));
        }
    }

    public class HashMap
    {
        public uint CalculateUintCapacity(uint initCapacity, float loadFactor)
        {
            if (loadFactor <= 0) 
            {
                throw new ArgumentOutOfRangeException(nameof(loadFactor));                
            } 
            return (uint)(initCapacity / loadFactor);
        }
    }
}
