// ********RoostGPT********
/*
Test generated by RoostGPT for test roostAI-csharp-sample using AI Type Azure Open AI and AI Model roost-gpt4-32k

ROOST_METHOD_HASH=LoadAndRunPlugins_c42a77c27f
ROOST_METHOD_SIG_HASH=LoadAndRunPlugins_24f4f0bf3c

   ########## Test-Scenarios ##########  

Scenario 1: Test Valid Type Loaded And Ran Successfully
  Details:
    TestName: TestLoadAndRunPluginsWithValidType.
    Description: Test meant to check when we provide the type for which we have matching plugins, how our method behaves and makes sure it loads and runs successfully.
  Execution:
    Arrange: Initialize type argument with a valid plugin type that exists; ensure the Composer and PluginLocation properties are also set.
    Act: Invoke the LoadAndRunPlugins method with the valid plugin type.
    Assert: Verify that the returned integer should be the equivalent ErrorCode for successful execution.
  Validation:
    This test aims to verify that the inputtype has an associated plugin and was successfully loaded and run. This will validate the expected behavior of the process when given a valid plugin type.

Scenario 2: Test Null Type Parameter
  Details:
    TestName: TestLoadAndRunPluginsWithNullType.
    Description: Test meant to check null type parameter handling in LoadAndRunPlugins method.
  Execution:
    Arrange: Initialize type argument as null.
    Act: Invoke the LoadAndRunPlugins method with null type argument.
    Assert: Verify that the returned integer is 11.
  Validation:
    This test aims to verify null type input handling. It should return an integer code for this specific exception, which we know is 11. 

Scenario 3: No Composer Set
  Details:
    TestName: TestLoadAndRunPluginsWithoutComposerSet.
    Description: Test meant to check how LoadAndRunPlugins method handles when Composer property isn't set.
  Execution:
    Arrange: Initialize type argument with a valid plugin type, but don't set the Composer property.
    Act: Invoke the LoadAndRunPlugins method with the plugin type.
    Assert: Verify that the returned integer is 12.
  Validation:
    This test scenario checks the condition when the Composer hasn't been initialized. It should return the integer code for this specific type of exception, which is 12.

Scenario 4: Plugin Location Not Set
  Details:
    TestName: TestLoadAndRunPluginsWithoutPluginLocation.
    Description: Test meant to check how LoadAndRunPlugins method handles when PluginLocation isn't set.
  Execution:
    Arrange: Initialize type argument with a valid plugin type and set Composer but don't set PluginLocation property.
    Act: Invoke the LoadAndRunPlugins method with the plugin type.
    Assert: Verify that the returned integer is 13.
  Validation:
    This scenario checks the condition when PluginLocation isn't set, which should return 13 indicating that the plugin location exception was thrown.

Scenario 5: Plugin Type Not Found
  Details:
    TestName: TestLoadAndRunPluginsWithNoMatchingType.
    Description: Test meant to check how LoadAndRunPlugins method behaves when provided a plugin type for which no matching plugins exist.
  Execution:
    Arrange: Initialize type argument with an invalid or non-existent plugin type.
    Act: Invoke the LoadAndRunPlugins method with the non-existent plugin type.
    Assert: Verify that the returned integer is 14.
  Validation:
    This test aims to validate the condition where no plugins of the given type are available. It helps ensure that our program can handle such conditions correctly.
*/

// ********RoostGPT********
using System;
using System.Collections.Generic;
using System.ComponentModel.Composition;
using System.ComponentModel.Composition.Hosting;
using System.Linq;
using NUnit.Framework;
using Moq;
using PluginInterface;
using SimpleClassLibrary;

namespace SimpleClassLibrary.Test
{
    [TestFixture]
    public class LoadAndRunPluginsTest
    {
        private Mock<IComposer> _mockComposer;
        private PluginLoader _pluginLoader;

        [SetUp]
        public void SetUp()
        {
            _mockComposer = new Mock<IComposer>();
            _pluginLoader = new PluginLoader();
        }

        [Test]
        public void TestLoadAndRunPluginsWithValidType()
        {
            // Arrange
            var pluginMock = new Mock<IPlugin>();
            const string type = "validType";
            pluginMock.Setup(x => x.Run()).Returns(ErrorCode.NoError);
            _pluginLoader.Composer = _mockComposer.Object;
            _pluginLoader.PluginLocation = "testLocation";
            _mockComposer.Setup(x => x.ComposePlugins(_pluginLoader)).Returns(new List<Lazy<IPlugin, IDictionary<string, object>>>
            {
                new Lazy<IPlugin, IDictionary<string, object>>(() => pluginMock.Object, new Dictionary<string, object>{{"Type", type}})
            }.ToArray);

            // Act
            var result = _pluginLoader.LoadAndRunPlugins(type);

            // Assert
            Assert.AreEqual((int)ErrorCode.NoError, result);
        }

        [Test]
        public void TestLoadAndRunPluginsWithNullType()
        {
            // Act
            var result = _pluginLoader.LoadAndRunPlugins(null);

            // Assert
            Assert.AreEqual(11, result);
        }

        [Test]
        public void TestLoadAndRunPluginsWithoutComposerSet()
        {
            // Arrange
            const string type = "validType";
            _pluginLoader.PluginLocation = "testLocation";

            // Act
            var result = _pluginLoader.LoadAndRunPlugins(type);

            // Assert
            Assert.AreEqual(12, result);
        }

        [Test]
        public void TestLoadAndRunPluginsWithoutPluginLocation()
        {
            // Arrange
            const string type = "validType";
            _pluginLoader.Composer = _mockComposer.Object;

            // Act
            var result = _pluginLoader.LoadAndRunPlugins(type);

            // Assert
            Assert.AreEqual(13, result);
        }

        [Test]
        public void TestLoadAndRunPluginsWithNoMatchingType()
        {
            // Arrange
            var pluginMock = new Mock<IPlugin>();
            const string type = "validType";
            pluginMock.Setup(x => x.Run()).Returns(ErrorCode.NoError);
            _pluginLoader.Composer = _mockComposer.Object;
            _pluginLoader.PluginLocation = "testLocation";
            _mockComposer.Setup(x => x.ComposePlugins(_pluginLoader)).Returns(new List<Lazy<IPlugin, IDictionary<string, object>>>
            {
                new Lazy<IPlugin, IDictionary<string, object>>(() => pluginMock.Object, new Dictionary<string, object>{{"Type", "anotherType"}})
            }.ToArray);

            // Act
            var result = _pluginLoader.LoadAndRunPlugins(type);

            // Assert
            Assert.AreEqual(14, result);
        }
    }
}
