// ********RoostGPT********
/*
Test generated by RoostGPT for test roostAI-csharp-sample using AI Type Azure Open AI and AI Model roost-gpt4-32k

ROOST_METHOD_HASH=Run_266bcfe910
ROOST_METHOD_SIG_HASH=Run_4118f49c75

   ########## Test-Scenarios ##########  

Scenario 1: Test scenario when the service is not loaded
  Details:
    TestName: TestServiceNotLoaded.
    Description: This test is to check if the service is not loaded an exception should be thrown.
  Execution:
    Arrange: Ensure _service is null.
    Act: Call the Run() method.
    Assert: An Exception is expected.
  Validation:
    The assertion aims to verify that an exception is thrown when the service is not loaded. This is essential as the execution can't proceed without the service, validating the application's robustness.

Scenario 2: Test scenario when the state of the service is Active
  Details:
    TestName: TestActiveService.
    Description: This test is meant to check if the correct error code is returned when the service state is Active.
  Execution:
    Arrange: Set service state as State.Active.
    Act: Call the Run() method.
    Assert: ErrorCode.NoError is expected.
  Validation:
    The assertion aims to verify that when the service is active, no error occurs, which aligns with the expected current business rules.

Scenario 3: Test scenario when the state of the service is Reactive
  Details:
    TestName: TestReactiveService.
    Description: This test is meant to check if the correct error code is returned when the service state is Reactive.
  Execution:
    Arrange: Set service state as State.Reactive.
    Act: Call the Run() method.
    Assert: ErrorCode.Error1 expected.
  Validation:
    The assertion aims to verify the expected return error for the Reactive service state. The business significance is the proper categorization of error types based on the service status.

Scenario 4: Test scenario when the state of the service is Pending
  Details:
    TestName: TestPendingService.
    Description: This test is meant to check if the correct error code is returned when the service state is Pending.
  Execution:
    Arrange: Set service state as State.Pending.
    Act: Call the Run() method.
    Assert: ErrorCode.Error2 is expected.
  Validation:
    The assertion aims to assure the appropriate error return when the service is pending. This aligns with the service's state management rules.

Scenario 5: Test scenario for all other states of the service (Loading, Initializing, Restarting, Starting)
  Details:
    TestName: TestOtherStatesService.
    Description: This test is to check whether the correct error code is being returned for each separate remaining state.
  Execution:
    Arrange: For each test, set the service state as State.Loading, State.Initializing, State.Restarting, State.Starting.
    Act: Call the Run() method.
    Assert: For each state, ErrorCode.Error3, ErrorCode.Error4, ErrorCode.Error5, ErrorCode.Error6 are expected respectively.
  Validation:
    The assertion aims to verify the correctly associated error codes to the corresponding states of the service. These rules are an essential part of state management and error handling.

Scenario 6: Test scenario when the state of the service is not any of the defined states
  Details:
    TestName: TestUndefinedServiceState.
    Description: This test is meant to check if the correct error code is returned when the service state is not any of the defined states.
  Execution:
    Arrange: Set the service state as undefined.
    Act: Call the Run() method.
    Assert: ErrorCode.ErrorDefault is expected.
  Validation:
    This assertion helps validate that for any unknown or undefined service state, the application behaves predictably and returns a default error.
*/

// ********RoostGPT********
using System;
using NUnit.Framework;
using Moq;
using CommonServiceLocator;
using PluginInterface;
using RealtimePlugin;

namespace RealTimePlugin.Test
{
    [TestFixture]
    public class RunTest
    {
        private RealtimePlugin.RealTimePlugin _realTimePlugin;
        private Mock<IService> _serviceMock;

        [SetUp]
        public void Setup()
        { 
            _serviceMock = new Mock<IService>();
            ServiceLocator.SetLocatorProvider(() => new SimpleIocAdapter(_serviceMock.Object));
            _realTimePlugin = new RealtimePlugin.RealTimePlugin();
        }

        [Test]
        public void TestServiceNotLoaded()
        { 
            _serviceMock.Setup(s => s.GetState()).Returns(State.Unavailable);
            var ex = Assert.Throws<Exception>(() => _realTimePlugin.Run());
            Assert.That(ex.Message, Is.EqualTo("service not loaded"));
        }

        [Test]
        public void TestActiveService()
        {
            _serviceMock.Setup(s => s.GetState()).Returns(State.Active);

            var output = _realTimePlugin.Run();

            Assert.AreEqual(ErrorCode.NoError, output);
        }

        [Test]
        public void TestReactiveService()
        {
            _serviceMock.Setup(s => s.GetState()).Returns(State.Reactive);

            var output = _realTimePlugin.Run();

            Assert.AreEqual(ErrorCode.Error1, output);
        }

        [Test]
        public void TestPendingService()
        {
            _serviceMock.Setup(s => s.GetState()).Returns(State.Pending);

            var output = _realTimePlugin.Run();

            Assert.AreEqual(ErrorCode.Error2, output);
        }

        [TestCase(State.Loading, ErrorCode.Error3)]
        [TestCase(State.Initializing, ErrorCode.Error4)]
        [TestCase(State.Restarting, ErrorCode.Error5)]
        [TestCase(State.Starting, ErrorCode.Error6)]
        public void TestOtherStatesService(State serviceState, ErrorCode expectedErrorCode)
        {
            _serviceMock.Setup(s => s.GetState()).Returns(serviceState);

            var output = _realTimePlugin.Run();

            Assert.AreEqual(expectedErrorCode, output);
        }

        [Test]
        public void TestUndefinedServiceState()
        {
            _serviceMock.Setup(s => s.GetState()).Returns((State)100);

            var output = _realTimePlugin.Run();

            Assert.AreEqual(ErrorCode.ErrorDefault, output);
        }
    }
}
